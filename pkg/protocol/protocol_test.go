package protocol_test

import (
	`bytes`
	`encoding/json`
	`os`
	`testing`

	`github.com/ambientsound/aidon-ams-prometheus-exporter/pkg/protocol`
	`github.com/stretchr/testify/assert`
)

// 2022/08/17 01:28:50 DATA [42 B]
var data1 = []byte{
	// APDU:
	// - Tag
	// - Long-invoke-id-and-priority
	// - Date-time
	// - Notification-body
	//   - Datatype
	//   - Len
	//   - Register 1..N

	// LLC
	0xa0, 0x2a, // some ID?
	0x41, 0x08, 0x83, 0x13, // static?
	0x04, 0x13, // some ID?
	0xe6, 0xe7, 0x00,

	// xDLMS APDU
	0x0f, // data-notification
	0x40,
	// long-invoke-id-and-priority
	0x00, 0x00, 0x00, 0x00,
	0x01, 0x01, // msg type?

	0x02, 0x03, 0x09, 0x06,
	// OBIS identifier: active power +
	0x01, 0x00, 0x01, 0x07, 0x00, 0xff,

	0x06, 0x00, 0x00,
	0x04, 0xf9, // changes each round (non-incremental, real data?)

	0x02, 0x02, 0x0f, 0x00, 0x16, 0x1b,
	0x18, 0xe7, // changes each round (crc?)
}

var data2 = []byte{0xa0, 0x2a, 0x41, 0x08, 0x83, 0x13, 0x04, 0x13, 0xe6, 0xe7, 0x00, 0x0f, 0x40, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x02, 0x03, 0x09, 0x06, 0x01, 0x00, 0x01, 0x07, 0x00, 0xff, 0x06, 0x00, 0x00, 0x04, 0xe9, 0x02, 0x02, 0x0f, 0x00, 0x16, 0x1b, 0xd1, 0x52}
var data3 = []byte{0xa0, 0x2a, 0x41, 0x08, 0x83, 0x13, 0x04, 0x13, 0xe6, 0xe7, 0x00, 0x0f, 0x40, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x02, 0x03, 0x09, 0x06, 0x01, 0x00, 0x01, 0x07, 0x00, 0xff, 0x06, 0x00, 0x00, 0x04, 0xfb, 0x02, 0x02, 0x0f, 0x00, 0x16, 0x1b, 0xa3, 0xd0}
var data4 = []byte{0xa1, 0x0b, 0x41, 0x08, 0x83, 0x13, 0xfa, 0x7c, 0xe6, 0xe7, 0x00, 0x0f, 0x40, 0x00, 0x00, 0x00, 0x00, 0x01, 0x0c, 0x02, 0x02, 0x09, 0x06, 0x01, 0x01, 0x00, 0x02, 0x81, 0xff, 0x0a, 0x0b, 0x41, 0x49, 0x44, 0x4f, 0x4e, 0x5f, 0x56, 0x30, 0x30, 0x30, 0x31, 0x02, 0x02, 0x09, 0x06, 0x00, 0x00, 0x60, 0x01, 0x00, 0xff, 0x0a, 0x10, 0x37, 0x33, 0x35, 0x39, 0x39, 0x39, 0x32, 0x38, 0x39, 0x35, 0x38, 0x30, 0x33, 0x36, 0x33, 0x32, 0x02, 0x02, 0x09, 0x06, 0x00, 0x00, 0x60, 0x01, 0x07, 0xff, 0x0a, 0x04, 0x36, 0x35, 0x32, 0x35, 0x02, 0x03, 0x09, 0x06, 0x01, 0x00, 0x01, 0x07, 0x00, 0xff, 0x06, 0x00, 0x00, 0x04, 0xf9, 0x02, 0x02, 0x0f, 0x00, 0x16, 0x1b, 0x02, 0x03, 0x09, 0x06, 0x01, 0x00, 0x02, 0x07, 0x00, 0xff, 0x06, 0x00, 0x00, 0x00, 0x00, 0x02, 0x02, 0x0f, 0x00, 0x16, 0x1b, 0x02, 0x03, 0x09, 0x06, 0x01, 0x00, 0x03, 0x07, 0x00, 0xff, 0x06, 0x00, 0x00, 0x00, 0x00, 0x02, 0x02, 0x0f, 0x00, 0x16, 0x1d, 0x02, 0x03, 0x09, 0x06, 0x01, 0x00, 0x04, 0x07, 0x00, 0xff, 0x06, 0x00, 0x00, 0x02, 0xbd, 0x02, 0x02, 0x0f, 0x00, 0x16, 0x1d, 0x02, 0x03, 0x09, 0x06, 0x01, 0x00, 0x1f, 0x07, 0x00, 0xff, 0x10, 0x00, 0x1c, 0x02, 0x02, 0x0f, 0xff, 0x16, 0x21, 0x02, 0x03, 0x09, 0x06, 0x01, 0x00, 0x47, 0x07, 0x00, 0xff, 0x10, 0x00, 0x1f, 0x02, 0x02, 0x0f, 0xff, 0x16, 0x21, 0x02, 0x03, 0x09, 0x06, 0x01, 0x00, 0x20, 0x07, 0x00, 0xff, 0x12, 0x09, 0x6a, 0x02, 0x02, 0x0f, 0xff, 0x16, 0x23, 0x02, 0x03, 0x09, 0x06, 0x01, 0x00, 0x34, 0x07, 0x00, 0xff, 0x12, 0x09, 0x7b, 0x02, 0x02, 0x0f, 0xff, 0x16, 0x23, 0x02, 0x03, 0x09, 0x06, 0x01, 0x00, 0x48, 0x07, 0x00, 0xff, 0x12, 0x09, 0x64, 0x02, 0x02, 0x0f, 0xff, 0x16, 0x23}

func TestParseString(t *testing.T) {
	data := []byte{
		0x0b,                                                             // length
		0x41, 0x49, 0x44, 0x4f, 0x4e, 0x5f, 0x56, 0x30, 0x30, 0x30, 0x31, // data
	}
	r := bytes.NewReader(data)
	s, err := protocol.ParseString(r)
	assert.NoError(t, err)
	assert.Equal(t, "AIDON_V0001", s)
}

func TestParseAny(t *testing.T) {
	r := bytes.NewReader(data4[17:])
	s, err := protocol.ParseAny(r)
	assert.NoError(t, err)
	enc := json.NewEncoder(os.Stdout)
	enc.SetIndent("", "  ")
	enc.Encode(s)
}

func TestParseFlattened(t *testing.T) {
	r := bytes.NewReader(data4[17:])
	s, err := protocol.ParseFlattened(r)
	enc := json.NewEncoder(os.Stdout)
	enc.SetIndent("", "  ")
	enc.Encode(s)
	assert.NoError(t, err)
}
